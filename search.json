{"entries":[{"title":null,"url":"http://mumufeixia.github.io//posts/about-cn.html","date":null,"categories":[],"body":"\n"},{"title":"ubuntu 环境搭建初始化","url":"http://mumufeixia.github.io//linux/2013/11/27/ubuntu-initial.html","date":"2013-11-27 00:00:00 +0800","categories":["linux"],"body":"##删除IBUS\nsudo apt-get autoremove ibus\n\n##install fcitx\n    sudo add-apt-repository ppa:fcitx-team/nightly->add source ->then /etc/apt/source.d/ will come up with one file fcitx-team-stable-saucy.list\n    after this need:sudo apt-get update\n    sudo apt-get install fcitx\n    im-config -s fcitx(13.10 use im-config not im-switch) //use fcitx\n    sudo apt-get install fcitx-googlepinyin //install googlepinyin\n    fcitx -r //restart it then can configue\n\n##delete useless icon from panel \nsudo apt-get auremove indicator-keyboard\n\n##log out command\ngnome-session-quit\n\n##安装flash player\nsudo apt-get install flashplugin-installer\n##安装chromium\nsudo apt-get install chromium-browser\n\n##安装goagent\n安装完成后chromim里面配置switch proxy， ps aux | grep proxy.py 查看进程，然后可以用kill杀死进程或者直接在goagnet命令行界面Ctrl+C退出proxy\n证书设置：http://blog.netsh.org/posts/goagent-https-ssl-error_1013.netsh.html\n\n##安装vim\n    sudo apt-get install vim\n    vim .vimrc\n    mkdir .vim\n    git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle\n进入vim BundleInstall安装完成\n\n##安装jekyll\n1.安装rvm：ruby版本管理器https://rvm.io/\ncurl -L https://get.rvm.io | bash -s stable\n检查安装：rvm list known\n安装ruby：rvm install 2.0.0\n让gnome-terminal以登录模式使用命令：https://rvm.io/integration/gnome-terminal\nruby -v 检查版本\nruby -e \"print 'hello ruby'\" 运行ruby\nirb 进入命令行ruby模式\n2.安装bundler:\ngem install bundler\ngem install jekyll //这里遇到问题：Unable to download data from https://rubygems.org/ - no such name (https://rubygems.org/latest_specs.4.8.gz)\n说是ruby-head什么原因。\n运行gem update --system 后成功按照jekyll\n\n##项目权限及配置ssh\n权限问题一直很烦，又一直很懒，懒的去看怎么弄的，今天小看了一下就设置了一下\n在/var/ 下面用root帐号建立了一个www权限，这时候而已看到www目录所有者和组都是root\nlinux组在/etc/group里面设置的（http://linux.vbird.org/linux_basic/0410accountmanager.php#passwd_file）里面有个www-data,末尾添加ray,向组里添加用户就直接在这个后面添加就可以了用，分割\n    sudo chown ray www->更改所有者\n    sudo chgrp ray www\n完了之后www就是属于ray的并且组为www-data，如果有其他用户需要使用 就更改权限即可\n\n添加ssh并和git关联\nhttps://help.github.com/articles/generating-ssh-keys\n按照上面的步骤其中有一步我没有做\nssh-add id_rsa，这个是将密钥添加到ssh-gen，我目前的理解是ssh-gen是作为ssh的服务的时候使用的，而我目前只是要作为客户端，所以不需要这个\n\n##刚刚找到一个很好用vim的命令\n\ndf$char--->删除当前字符到$char,包括$char\ndt$char--->删除当前字符到$char,不包括$char\n\n\n同样的 yf 和 yt 也是同样的道理\n\n"},{"title":"LNMP 编译安装","url":"http://akulubala.github.io//linux/2013/12/08/install-lnmp.html","date":"2013-12-08 00:00:00 +0800","categories":["linux"],"body":"首先安装PCRE 来支持rewrite\n\n  下载地址：ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/ \n  解压缩：sudo tar -zxvf pcre-8.30.tar.gz  -C /usr/local/src\n  建立安装目录：cd /usr/local  && sudo mkdir pcre\n  安装：./configure –prefix=/usr/local/pcre\n make&&sudo make install\n  安装完成之后测试!!!\n再安装Zlib\n—-\n1.下载地址：http://prdownloads.sourceforge.net/libpng/zlib-1.2.8.tar.gz?download\n2.cd /usr/local/src然后：ln -s ~/Downloads Downloads 将Downloads目录做个软链接\n3.tar -zxvf zlib-1.2.8.tar.gz -C /usr/local/src\n4.安装：./configure –prefix=/usr/local/zlib\n  make&&sudo make install\n5.用whereis zlib 检查安装成功（是函数库非可执行文件）\n安装nginx\n—\n1.解压缩这里就不废话了，直接放到src下\n2.cd /usr/local/\nsudo mkdir lnmp\nsudo chown ray lnmp\nsudo chgrp www-data lnmp\n编译：./configure –prefix=/usr/local/lnmp/nginx –with-pcre=/usr/local/src/pcre-8.30 –with-zlib=/usr/local/src/zlib-1.2.8 –with-http_ssl_module\n这里注意：pcre和zlib的路径是源文件路径，所以前面我做了两步都是无用功了ngnix自己编译，我遇的到啊～:–with-pcre=path — sets the path to the sources of the PCRE library.\n3.安装：\nmake&&make install\n安装Mysql\n—\n1.下载地址：http://dev.mysql.com/downloads/file.php?id=450353\n2.解压到src目录\n3.建立mysql用户:\nsudo /usr/sbin/groupadd mysql\nsudo /usr/sbin/useradd -g mysql mysql\n将自己当前帐号加入mysql 组：usermod -a -G mysql ray \n4.cd /usr/local/\nsudo mkdir mysql \ncd mysql\nsudo mkdir mysql_data\n4.切换到源文件根目录：sudo cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lnmp/mysql -DMYSQL_UNIX_ADDR=/usr/local/lnmp/mysql/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS:STRING=utf8,gbk -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_DATADIR=/usr/local/lnmp/mysqldata\n\n详细配置说明地址：http://dev.mysql.com/doc/refman/5.6/en/source-configuration-options.html\n5.sudo make && sudo make install\n6.sudo cp my-default.cnf /usr/local/lnmp/mysqldata/my.cnf  (注意:my-large.cnf适用于1G内存左右的服务器，可以根据自己配置情况选用my-large.cnf 或 my-huge.cnf 等不同配置)\nsudo cp mysql.server /etc/init.d/mysqld\n编辑mysqld,basedir=/usr/local/lnmp/mysql;datadir=/usr/local/lnmp/mysqldata\n  sudo ./mysql_install_db –defaults-file=/usr/local/lnmp/mysqldata/my.cnf –basedir=/usr/local/lnmp/mysql datadir=/usr/local/lnmp/mysqldata –user=mysql\n  将mysqld加入服务，直接重启也可以：sudo apt-get install sysv-rc-confsudo sysv-rc-conf mysqld on\n  测试：service mysqld restart\n10.缺省安装的mysql是没有密码的，所以我们要修改，以防万一。下面采用三种方式来修改root的口令。 \ncd /usr/local/lnmp/mysql/bin/mysqladmin -uroot password test \n·\n更多安全参考](http://www.cnblogs.com/xh831213/archive/2011/10/13/2210194.html)\nPHP 安装\n—\n1.安装libxml\n  用于解析xml的：下载完成后解压缩到/usr/local/libxml\n2.jpeg安装,下载http://www.ijg.org/files/jpegsrc.v9.tar.gz\n解压缩到/usr/local/src/目录\n./configure –prefix=/usr/local/jpeg-9->make&&sudo make install\n3.安装PNG支持下载:libpng\n./configure –prefix=/usr/local/libpng->make&&sudo make install\n4.Freetype安装，下载,安装:./configure –prefix=/usr/local/freetype->make&&sudo make install\n5.libmcrypt安装,下载安装：./configure –prefix=/usr/local/libmcrypt-2.5.8->make&&sudo make install\n6.mhash 安装,下载安装：./configure –prefix=/usr/local/libmcrypt-2.5.8->make&&sudo make install\n7.mcrypt下载\n注意第七条依赖于5,6\n直接编译出错\n然后执行以下操作：\n>1.~/.profile 里面加入export      LD_LIBRARY_PATH=/usr/local/libmcrypt-2.5.8/lib:/usr/local/mhash-0.9.9.9/lib 配置前面两个库的lib地址\n>2../configure –prefix=/usr/local/mcrypt-2.6.8 –with-libmcrypt-prefix=/usr/local/libmcrypt-2.5.8\n\n\n可惜又报另一个错误\n参考这里\nexport CFLAGS=”-I /usr/local/mhash-0.9.9.9/include/”\nexport LDFLAGS=”-L /usr/local/mhash-0.9.9.9/lib -I /usr/local/mhash-0.9.9.9/include/”\n再次执行configure 通过,但是make&&sudo make install 却报错\n结果再参考make file 选项\n发现上面两条export 是不正确的\n正确的应该是：\n>export LDFLAGS=”-L/usr/local/libmcrypt-2.5.8/lib -L/usr/local/mhash-0.9.9.9/lib”;\n>export CFLAGS=”-I/usr/local/libmcrypt-2.5.8/include -I/usr/local/mhash-0.9.9.9/include”\n\n注：/etc/ld.so.conf,关于.so动态库的载入参考鸟哥(http://linux.vbird.org/linux_basic/0520source_code_and_tarball.php)\n\n最终编译安装mcrypt 成功,以上PHP 依赖库安装完毕\n####接下来正式PHP 安装\n1.下载并加压后\n>export LIBS=”-lm -ltermcap -lresolv”(注：这句我不晓得是什么意思所以没用)\n>export LD_LIBRARY_PATH=”/usr/local/lnmp/mysql/lib:/lib:/usr/lib/:/usr/local/lib/:/usr/local/libmcrypt-2.5.8/lib/:/usr/local/mhash-0.9.9.9/lib/:/lib64/:/usr/lib64/:/usr/local/lib64/” (参考不同操作系统设置:http://blog.chinaunix.net/uid-14504139-id-3867128.html)\n\n../configure\n--prefix=/usr/local/lnmp/php\n--with-config-file-path=/usr/local/lnmp/php/etc \n--with-mysql=/usr/local/lnmp/mysql --with-mysqli=/usr/local/lnmp/mysql/bin/mysql_config \n--with-freetype-dir=/usr/local/freetype --with-jpeg-dir=/usr/local/jpeg-9\n--with-png-dir=/usr/local/libpng\n--with-zlib\n--with-libxml-dir=/usr/local/libxml2 \n--enable-xml \n--disable-rpath \n--enable-bcmath \n--enable-shmop[消息队列](http://wizardmin.com/2012/08/php-ipc-sysvmsg/) \n--enable-sysvsem\n--enable-inline-optimization(使用更多内存加快程序结果)\n--with-curl\n--enable-mbregex\n--enable-fpm\n--enable-mbstring\n--with-mcrypt=/usr/local/mcrypt\n--with-gd\n--enable-gd-native-ttf\n--with-openssl\n--with-mhash \n--enable-pcntl（打开进程控制支持）\n--enable-sockets\n--with-xmlrpc\n--enable-zip\n--enable-soap \n--enable-fpm(开始没有加这个NGINX 就没办法解析PHP 有些作者真是肯跌啊)\n\n出错啦：\n解决方法：sudo apt-get install libcurl4-gnutls-dev 就不编译安装啦\n再次错错：error: mcrypt.h not found. Please reinstall libmcrypt\n解决方法：sudo apt-get install libmcrypt-dev很纳闷\n再次错误：找不到mysql_config 这次是打字错误，更郁闷\n\n完整configure： ./configure\n--prefix=/usr/local/lnmp/php  \n--with-config-file-path=/usr/local/lnmp/php/etc  \n--with-mysql=/usr/local/lnmp/mysql  \n--with-mysqli=/usr/local/lnmp/mysql/bin/mysql_config  \n--with-pdo-mysql=/usr/local/lnmp/mysql  \n--with-mysql-sock=/usr/local/lnmp/mysql/mysql.sock  \n--with-freetype-dir=/usr/local/freetype  \n--enable-fpm  \n--with-fpm-user=ray  \n--with-fpm-group=www-data  \n--with-jpeg-dir=/usr/local/jpeg-9  \n--with-png-dir=/usr/local/libpng  \n--with-zlib  \n--with-libxml-dir=/usr/local/libxml2  \n--enable-xml  \n--enable-bcmath  \n--enable-shmop  \n--enable-sysvsem  \n--enable-inline-optimization  \n--with-curl  \n--enable-mbregex  \n--enable-mbstring  \n--with-mcrypt=/usr/local/mcrypt  \n--with-gd  \n--enable-gd-native-ttf  \n--with-openssl  \n--with-mhash  \n--enable-pcntl  \n--enable-sockets  \n--enable-zip  \n--enable-soap\nmake&&make test&&make install\n启动php-fpm,cd /usr/local/lnmp/php/sbin/php-fpm\n"},{"title":"Zend Framework 2 集成mustache","url":"http://akulubala.github.io//zf2/2013/12/27/Zend-framework2-intergrate-mustache.html","date":"2013-12-27 00:00:00 +0800","categories":["zf2"],"body":"\n  首先下载mustache 模块，https://github.com/widmogrod/zf2-mustache-module，按照说明可以使用composer安装，但是我喜欢自己定义路径，一步步安装，所以我的目录结构如下：  \n![mustcache][1]\n  [1]: http://akulubala.github.io/public/images/2013/mustache.jpg  \nmustache php源代放在了ThirdPart目录下，  \n然后将下载下来的mustache zend模块放到module 里面，和(Application)模块同级目录  \n  在public/index.php中添加如下语句：  \n\n\ninclude 'system/ThirdPart/Mustache/Autoloader.php';  \n        Mustache_Autoloader::register();\n\n\n  \n    路径放好之后配置根目录下application.config.php  \n\n    'modules' => array(\n    'Mustache',//这里注意顺序，因为所有模块都要使用所以要放在最前面\n    'Akulubala',\n    'Application'\n)\n    \n  \n  \n    更改module 目录下 mustache/config/module.config.php  \n\n    ‘mustache’ => array(\n           ‘suffix’ => ‘mustache’,\n           ‘suffixLocked’ => true,\n           ‘cache’ => PROJECT_PATH. ‘data/mustache’ // 这个数组里面可以配置mustache，PORJECT_PATH 是项目根路径\n   )\n  \n  \n    现在更改Application module 里面的application/config/module.config.php  ,添加下面一段到view_manager 数组里面  \n\n    ‘strategies’ => array(\n           ‘Mustache\\View\\Strategy’\n   )\n  \n  \n    现在就可以在每个模块的view里面使用mustache了，建立index.mustache 测试，通过..具体原理还是要多读读代码，通过这个配置  \n了解了zend framework 2模块的使用，即插即用的使用方式，Application module是必须的作为bootstrap使用\n  \n\n"},{"title":"一些有用的javascript技巧，持续更新...","url":"http://akulubala.github.io//javascript/2014/01/08/Some-useful-javascript-tips.html","date":"2014-01-08 00:00:00 +0800","categories":["javascript"],"body":"\n  \n    不要忘记var在变量初始化的时候\n  \n  \n    使用===替代==,!==替代!=,==和!=会自动转换类型,===和!==不仅会比较值还会比较类型\n  \n  \n    undefined,null,’‘,0,NaN,false都是布尔值false\n  \n  \n    创建对象的构造函数\n\n    function Person(firstName, lastName){\nthis.firstName =  firstName;\nthis.lastName = lastName;        \n}  \nvar Saad = new Person(\"Saad\", \"Mousliki\");\n    \n  \n  \n    使用typeof,instanceof,constructor的时候需要小心\n\n    var arr = [\"a\", \"b\", \"c\"];\ntypeof arr;   // return \"object\" \narr  instanceof Array // true\narr.constructor();\n    \n  \n  \n    创建闭包函数\n\n    (function(){\n  // some private code that will be executed automatically\n})();\n(function(a,b){\n       var result = a+b;\n       return result;\n})(10,20)\n    \n  \n  \n    从数组中得到一个随机项\n\n    var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];\nvar  randomItem = items[Math.floor(Math.random() * items.length)];\n    \n  \n  \n    从一个特定范围得到一个随机的数\n\n    var x = Math.floor(Math.random() * (max - min + 1)) + min;\n    \n  \n  \n    创建一个数组按照最小最大值\n\n    var numbersArray = [] , max = 100;\nfor( var i=1; numbersArray.push(i++) < max;);  // numbers = [0,1,2,3 ... 100]\n    \n  \n  \n    创建一个随机的字母数组组成的字符串\n\n    function generateRandomAlphaNum(len) {\n   var rdmstring = “”;\n   for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));\n   return  rdmString.substr(0, len);\n   }\n  \n  \n    打乱一个由数字组成的数组:\n\n    var numbers = [5,458,120,-215,228,400,122205,-85411];\n   numbers = numbers.sort(function(){ return Math.random() - 0.5});\n   /the array numbers will be equal for example to [120, 5, 228, -215, 400, 458, -85411, 122205]/\n  \n  \n    trim 字符串\n\n    \n      \n        \n          String.prototype.trim = function(){return this.replace(/^\\s+\n          \\s+$/g, “”);};\n        \n      \n    \n  \n  \n    把一个数组压入另一个数组头或者尾\n\n    var array1 = [12 , “foo” , {name “Joe”} , -2458];\n   var array2 = [“Doe” , 555 , 100];\n   Array.prototype.unshift.apply(array1, array2);-    array1=[“Doe”, 555, 100, 12, “foo”, Object { name=”Joe”}, -2458];\n   Array.prototype.push.apply(array1, array2);-    array1=[12, “foo”, Object { name=”Joe”}, -2458, “Doe”, 555, 100];\n   其中：apply (var1,var2)方法为默认每个函数都有的，它接受两个参数，第一个参数是传入的作用域，第二个为参数数组，通上例等价的还有:\n   Array.prototype.unshift.call(array1, “Doe”,555,100);\n   Array.prototype.push.call(array1, “Doe”,555,100);\n   其中call只是接受参数的方式和apply 不同，必须一个个传，而apply必须传数组\n  \n  \n    判断是否为数字:\n\n    function isNumber(n){\n   return !isNaN(parseFloat(n)) && isFinite(n);\n   }\n  \n  \n    判断是否为数组:\n\n    function isArray(obj){\n      return Object.prototype.toString.call(obj) === ‘[object Array]’ ;\n   }\n  \n  \n    获取数组中最大最小值\n\n    var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];\n   var maxInNumbers = Math.max.apply(Math, numbers);\n   var minInNumbers = Math.min.apply(Math, numbers);\n  \n  \n    清空数组和删除数组值\n\n    var myArray = [12 , 222 , 1000 ];\n   myArray.length = 0; // myArray will be equal to [].        \n   使用splice 删除数组的值，不要用delete，因为delete删除值会使原来位置为undefined        \n   var items = [12, 548 ,’a’ , 2 , 5478 , ‘foo’ , 8852, , ‘Doe’ ,2154 , 119 ];\n   items.length; // return 11\n   items.splice(3,1) ;\n   items.length; // return 10 items will be equal to [12, 548, “a”, 5478, “foo”, 8852, undefined × 1, “Doe”, 2154,119]\n  \n  \n    使用map方法遍历操作数组的值\n\n    var squares = [1,2,3,4].map(function (val) {\n      return val * val;\n   });\n   squares will be equal to [1, 4, 9, 16]\n  \n  \n    使用toFixed 四舍五入指定浮点数\n\n    var num =2.443242342;\n   num = num.toFixed(4);  // num will be equal to 2.4432\n  \n  \n    获取字符串长度，中文算两个英文\n  \n\n\n`value.replace(/[\\u4e00-\\u9fa5]/g,'**').length`\n\n\n\n  \n    定时，或者指定时间段内执行程序  \n\n    function startrefresh(){\n       setInterval(function(){\n\n           var  now  =  new  Date();\n       var year = now.getFullYear(),month=now.getMonth(),day=now.getDate();\n       var start_time =new Date(year,month,day,\"18\",\"07\",\"00\");\n       var end_time = new Date(year,month,day,\"23\",\"59\",\"59\");\n            \n       if((now > start_time) && (now <end_time )){\n           $.each($(\".ulDiv\").find(\"a\"),function(){\n               if(!$(this).hasClass(\"end_lottery\")&&!$(this).hasClass(\"nav\")){//这里这段代码是指定时间段内给元素添加class\n                   $(this).addClass(\"nav\");\n               }\n           });\n       }\n            \n   },500);     }    startrefresh();\n    \n  \n  \n    获取当前日期的方法  \n\n    var datelocalweek=new Array(“星期日”, “星期一”, “星期二”,”星期三”,”星期四”, “星期五”,”星期六”);\n   var datelocalnow=new Date();\n   var datelocalyear=datelocalnow.getFullYear();\n   var datelocalmonth=(“0”+(datelocalnow.getMonth()+1));\n   datelocalmonth=datelocalmonth.substr(datelocalmonth.length-2,2);\n   var datelocalday=”0”+datelocalnow.getDate();\n   datelocalday = datelocalday.substr(datelocalday.length-2,2);\n   var datelocalweekday=datelocalweek[datelocalnow.getDay()];\n   console.log(datelocalyear+”年”+datelocalmonth+”月”+datelocalday+”日”+” “+datelocalweekday);\n  \n\n"},{"title":"PHP 获取字符串长度，字节数...","url":"http://akulubala.github.io//php/2014/01/21/PHP-string-len-count.html","date":"2014-01-21 00:00:00 +0800","categories":["php"],"body":"PHP获取字符串长度有两个函数：mb_strlen 和strlen,mb_strlen在安装的时候加上–enable-mbstring 以支持国际化字符.\n用两个个文件来说明：\n\n\n  \n    首先建一个文件，文件默认编码为：ANSI格式，也就是平常建项目的时候建GBK编码的项目\n\n    $string = \"测试用的字符串abcdefg\";\n    \n1).  var_dump(mb_detect_encoding($string)).\"<br />\";//布尔值false\n    \n2).  echo mb_strlen($string).\"<br />\";//21\n    \n3).  echo mb_strlen($string,\"gbk\").\"<br />\";//14\n    \n4).  echo mb_strlen($string,\"utf-8\").\"<br />\";//16\n    \n5).  echo strlen($string).\"<br />\";21 上面的例子中1)中不给第二个参数的情况下为false,因为mbstring 里面mb_detect_order默认是没有检查中文的，所以改为：   `var_dump(mb_detect_encoding($string,\"gbk\"))`,这样的话结果就为CP936，说明确实是中文了，从2),3),4),5)中可以看出,正确的结果是3),2)和5)是把一个中文当两个字符处理，也就是在gbk下的字节数，gbk编码下中文字符是占两个字节，所以这两个   结果是将算出了字节数，也就是所谓的内部编码(文件的编码)，二第四个完全错了,这个是指定编码错误的情况下，具体怎么算了我也不清楚，\n    \n  \n  \n    再建一个文件使用UTF-8无BOM头部的文件，同样是上面的例子  \n\n    $string = \"测试用的字符串abcdefg\";  \n    \n1.var_dump(mb_detect_encoding($string,\"gbk,UTF-8\")).\"<br />\";//结果是CP936  \n    \n2.echo mb_strlen($string).\"<br />\";  //结果是28\n    \n3.echo mb_strlen($string,\"gbk\").\"<br />\";  //17\n    \n4.echo mb_strlen($string,\"utf-8\").\"<br />\";  //14\n    \n5.echo strlen($string).\"<br />\";//28\n    \n  \n\n\n上面例子1中结果错误,文件编码是utf-8，却检查出是cp936,说明检查的顺序有问题，这串字符串GBK可以通过，UTF-8也可以通过，所以正确的检查方式应该是var_dump(mb_detect_encoding($string,\"UTF-8,gbk\"))这样就对了。\n后面几个获取长度的例子中4是正确的，1，5是以文件编码来获取长度了也就是其实算的是字节数，3同样是 混乱出错\n\n所以检查字符串长度的正确方式应该是\n\nmb_strlen($string,mb_detect_encoding($string,”UTF-8,gbk”)),仅限中文和英文\n\n有些情况下喜欢 把一个中文当两个英文字符处理来算，可以用以下方式：\n\n(mb_strlen(trim($input[$field]),\"UTF-8\")+  strlen(trim($input[$field])))/2\n\n如果是GBK的直接 strlen就可以算出中文算两英文的长度了\n\n"},{"title":"PHP 上传进度条..","url":"http://akulubala.github.io//php/2014/03/04/PHP_Upload_Progress_bar.html","date":"2014-03-04 00:00:00 +0800","categories":["php"],"body":"####准备工作：\n\n\n  PHP5.4以上\n  php.ini 开启session.upload_progress.enable\n  更改这两个参数以适应大文件上传：post_max_size,upload_max_filesize\n\n\n####开始代码部分（直接贴了）：\n\n\n  \n    HTML(PHP copy上传文件，就在这里了省的再建个文件):\n\n    <?php\n    \nfunction help()\n{\n        foreach(func_get_args() as $v)\n        {\n            echo \"<pre>\";\n            var_dump($v);\n            echo \"</pre>\";\n        }\n    \n    die();\n}\nif ($_SERVER[\"REQUEST_METHOD\"] == \"POST\" && !empty($_FILES[\"userfile\"])) {\n    move_uploaded_file($_FILES['userfile']['tmp_name'], \"./a\");\n}\n?>  \n<html>\n<head>\n<title>File Upload Progress Bar</title>\n<style>\n...add css here\n</style>\n</head>\n<body>\n<div id=\"bar_blank\">\n<div id=\"bar_color\"></div>\n</div>\n<div id=\"status\"></div>\n<form action=\"\" method=\"POST\"   id=\"myForm\" enctype=\"multipart/form-data\">\n<input type=\"hidden\" value=\"myForm\"    name=\"<?php echo ini_get(\"session.upload_progress.name\"); ?>\">\n<input type=\"file\" name=\"userfile\"><br>\n<input type=\"submit\" value=\"Start Upload\">\n</form>\n<iframe id=\"hidden_iframe\" name=\"hidden_iframe\" src=\"about:blank\"></iframe>\n<script>\n...add javascript here\n</script>\n</body>\n</html>\n    \n\n    上面这段需要解释一下，1)Form里面有个隐藏域这个是必不可少的，用来带上上传session名称的，2)还有个IFrame     用来做类似无刷新上传的，3)div bar_blank这里是用来显示上传进度的\n  \n  \n    Javascript:\n\n    function toggleBarVisibility() {\n    var e = document.getElementById(\"bar_blank\");\n    e.style.display = (e.style.display == \"block\") ? \"none\" : \"block\";\n}\n    \nfunction createRequestObject() {\n    var http;\n    if (navigator.appName == \"Microsoft Internet Explorer\") {\n    http = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    else {\n    http = new XMLHttpRequest();\n    }\n    return http;\n}\n    \nfunction sendRequest() {\n    var http = createRequestObject();\n    http.open(\"GET\", \"progress.php\");\n    http.onreadystatechange = function () { handleResponse(http); };\n    http.send(null);\n}\n    \nfunction handleResponse(http) {\n    var response;\n    if (http.readyState == 4) {\n    response = http.responseText;\n    document.getElementById(\"bar_color\").style.width = response + \"%\";\n    document.getElementById(\"status\").innerHTML = response + \"%\";\n        \n    if (response < 100) {\n    setTimeout(\"sendRequest()\", 1000);\n    }\n    else {\n    toggleBarVisibility();\n    document.getElementById(\"status\").innerHTML = \"Done.\";\n    }\n    }\n}\n    \nfunction startUpload() {\n    toggleBarVisibility();\n    setTimeout(\"sendRequest()\", 1000);\n}\n    \n(function () {\ndocument.getElementById(\"myForm\").onsubmit = startUpload;\n})();\n    \n\n    以上Javascript主要是做了发送周期性的发送数据到progress.php,这个php返回上传进度然后javascript 更新div样式来反应上传的进度，可以用Jquery来做，理解了原理怎么样都可以\n  \n  \n    Progress.php:\n\n    session_start();\n$key = ini_get(\"session.upload_progress.prefix\") . \"myForm\";\nif (!empty($_SESSION[$key])) \n{    \n    $current = $_SESSION[$key][\"bytes_processed\"];\n    $total = $_SESSION[$key][\"content_length\"];\n    echo $current < $total ? ceil($current / $total * 100) : 100;\n}\nelse \n{\n    echo 100;\n}\n    \n\n    这个文件就是简单的计算上传比例然后返回给客户端。\n  \n\n\n####脚本跑过没有问题，原文来源：http://www.sitepoint.com/tracking-upload-progress-with-php-and-javascript/\n\n"},{"title":"PHP OAuth 2.0 认证流程..","url":"http://akulubala.github.io//php/2014/03/11/PHP-OAuth2.0(douban).html","date":"2014-03-11 00:00:00 +0800","categories":["php"],"body":"####oAuth2.0 授权认证\n\n首先官方文档的一个流程如下图(1.0)：\n\n +--------+                               +---------------+\n |        |--(A)- Authorization Request ->|   Resource    |\n |        |                               |     Owner     |\n |        |<-(B)-- Authorization Grant ---|               |\n |        |                               +---------------+\n |        |\n |        |                               +---------------+\n |        |--(C)-- Authorization Grant -->| Authorization |\n | Client |                               |     Server    |\n |        |<-(D)----- Access Token -------|               |\n |        |                               +---------------+\n |        |\n |        |                               +---------------+\n |        |--(E)----- Access Token ------>|    Resource   |\n |        |                               |     Server    |\n |        |<-(F)--- Protected Resource ---|               |\n +--------+                               +---------------+\n                    图1.0 我以<a href=\"http://developers.douban.com/wiki/?title=connect\" target=\"_blank\">豆瓣登陆</a>来说明上面流程,第三方登陆都是基本都是这么个流程：\n\n\n\n  \n    (A)->(B)流程是获取授权链接，其实就是我们点击豆瓣登陆按钮然后弹出一个登陆的窗口.这一步作为开发人员如果有做过豆瓣登陆的可以从豆瓣开发者里创建应用获取api key 和secret key,Api Key 是用来获取授权链接的，Secret Key是(C)->(D)中来获取Access Token的，豆瓣通过GET获取授权链接如下:\n\n    https://www.douban.com/service/auth2/auth?\nclient_id=0b5405e19c58e4cc21fc11a4d50aae64&\nredirect_uri=https://www.example.com/back&\nresponse_type=code&\nscope=shuo_basic_r,shuo_basic_w,douban_basic_common\n    \n  \n\n\n获取到授权链接后，就可以直接使用window.open(url)来弹出登陆窗口了\n 2. (C)->(D)流程是用来获取访问TOKEN的，得到这个Token后才能去访问用户的资源。在第一步中授权链接有注意到有三个参数，其中第一，二个是非常重要的，redirect url 是我自己网站的一个地址，当我们用账号第一次登陆后，资源方会问我们要不要给予第三方(也就是我们开发者的网站)授权，选择是之后，豆瓣就会根据response_type(上面是code)授权我们scope的权限，其实豆瓣会做一个get请求来调用我网站的redirect url,我们开发者就来获得了这个token（POST 方式）。\n\n         https://www.douban.com/service/auth2/token?\n        client_id=0b5405e19c58e4cc21fc11a4d50aae64&\n        client_secret=edfc4e395ef93375&\n        redirect_uri=https://www.example.com/back&\n        grant_type=authorization_code&\n        code=9b73a4248\n\n\n\n  \n    (E)->(F)流程就是来访问用户数据的了，通过第二步我们在redirect_url 页面上获得了access Token,接下来我们通过这个token 再去请求豆瓣服务资源，同样有一个开放接口，获取的用户信息后就可以do what you want了\n\n    curl \"https://api.douban.com/v2/user/~me\"\n -H \"Authorization: Bearer a14afef0f66fcffce3e0fcd2e34f6ff4\"\n    \n  \n\n\n以上就是OAuth 2.0 客户的一个流程，及客户端的一些基本操作    \n"},{"title":"使用Phuml 从PHP 代码生成UML 图..","url":"http://akulubala.github.io//php/2014/03/12/PHP-use-PHUMLmd.html","date":"2014-03-12 00:00:00 +0800","categories":["php"],"body":"####使用Phuml 生成php UML图\n一般来说项目大点了或者类多了都会最开始设计类关系图，鉴于大学里面学的差后来一直都没有用到，这个应该是个弊端。。\n另外现在有很多开源项目可以直接拿来用，但是一点点去看代码分析这个效率实在是太差了而且记不住，所以我就研究了很久关于这方面的工具，\n目前发现如果要先建立UML图，最好的工具是plaintUml，从代码去导出UML图目前PHP里面有PHuml，用了下不错的。。ok，不废话了。\n\n\n  Phuml 的项目地址：https://github.com/jakobwesthoff/phuml\n  使用此工具有个依赖工具 Graphviz,windows 下载地址为：http://www.graphviz.org/Download_windows.php,linux 下 以ubuntu 为例，直接：sudo apt-get install graphviz，需要设置环境变量使其能被全局访问\n  运行Phuml 必须有PHP 环境，因为它是PHP 写的，所以必须有PHP 环境 最好放个全局路径\n\n\n以上必须条件有了后：\n\n\n  下载Phuml 放到指定路径，比如/var/www/phuml-master.\n  命令行运行 php phuml -r {$sourceProjectPath} -graphviz -createAssociations false -neato {$resultImgName}\n\n\n就这么几步，但是看似简单的东西，再完全不明白的时候很可能会出错O(∩_∩)O,说我自己呢..\n上面两个变量一个是源路径就是需要生成UML 的项目路径，后面是生成的图片名称 例如a.png\n\n其他问题就看项目开发者的说明吧。。\n\n"},{"title":"Laravel 框架搭建..","url":"http://akulubala.github.io//laravel/2014/04/10/Laravel-Install.html","date":"2014-04-10 00:00:00 +0800","categories":["laravel"],"body":"  从哪里说起呢？做web开发也三年多了，最开始用zend（估计是浪费了些时间，最开始什么都不晓得），然后用codeigniter，codeigniter学起来不是那么费力，但是有很多是基于PHP4来的，一些引用什么的，面向过程什么的，感觉就不是特别想用。再后来公司开发都是些小的东西，就一直使用自己搭MVC出来做，但是自己搭的框架，总有些东西不是那么完善，对于新的技术，新开发思想也是很少能用的上的。前面就想找个适合的框架来开发，这时候Laravel貌似很火，就开始用上它了。用上了就是有中爱不释手的感觉。。    \n\n\n说起使用Laravel 就不得不掌握一些比较新的东西（其实也不新了O(∩_∩)O）如composer,namespace,匿名函数等等\n\n####Composer 的安装及使用：\nComposer是目前好用的PHP依赖包管理工具，它是从github 下载PHP包的。官方地址：https://getcomposer.org/\n安装的时候只有注意路径就好了。windows 下会指定PHP.exe路径，Linux 下：    \n\ncurl -sS https://getcomposer.org/installer | php\n\n\n下载下来之后名称为composer.phar\n使用 php composer.phar 检查是否安装成功\nComposer配置文件名为composer.json。以json格式存储信息,有个简单说明：    http://composer.json.jolicode.com/\n其中很多东西都不是必须的，具体解释还是看官方文档（我懒的写啊，太多了。我这么懒的人写博客简直是煎熬啊O(∩_∩)O）\n\ncomposer 了解的差不多了后是安装Laravel：\n\n官方是这么写的：composer create-project laravel/laravel your-project-name --prefer-dist\n\n网络好的话，应该很快下载完成。\n\n之后在composer.json 文件中更改为这么一段：\n\n     \"autoload\": {\n    \t\"classmap\": [\n    \t\t\"app/commands\",\n    \t\t\"app/database/migrations\",\n    \t\t\"app/database/seeds\",\n    \t\t\"app/tests/TestCase.php\"\n    \t],\n                \"psr-4\": {\n                        \"\": [\"app/module/\",\"app/library\"]\n                 }\n    }, 接下来执行composer dump-autoload.这段命令是重新生成自动加载文件的配置及路径等。上面的json代码中 PSR-4规范了如何指定文件路径从而自动加载类定义。比起PSR-0省去了两级目录，空引号表示会递归的去查找目录，module和library 这两个目录我是拿来做模块化和同样类库的。\n\n\n这些好了后，需要配置rewrite，apache的 不用做太多操作，laravel本身就已经有.htaccess做了rewrite\nNginx配置如下：\n\n    if (!-d $request_filename) {\n        rewrite ^/(.+)/$ /$1 permanent;\n    }\n\n\n"},{"title":"如何设置SSH的公钥授权","url":"http://akulubala.github.io//linux/2014/04/11/How-To-Set-Up-SSH-Publick-Key-Authentication.html","date":"2014-04-11 00:00:00 +0800","categories":["linux"],"body":"其实这个问题已经用过好几次了，但是基本上都是用的 时候再去查的，没有一个整体的概念，今天看到篇文章就翻译下来，顺带好好整理下思路：\n\n熟悉并能使用SSH的命令行操作对于web开发者来说是件很好的事情，这篇文章就是理解使用SSH命令行的一个进阶。讲解的内容有：\n\n\n    1理解公钥和私钥密码学术语\n    2隐式的SSH公钥认证和普通密码认证\n    3创建SSH公钥私钥\n    4设置好SSH公钥私钥\n    5不同的方式复制你的公钥到远程服务器\n    6创建SSH快捷方式\n\n\n####什么是密码学的公钥？\n\n\n  注意：这是个相当简单容易理解的，但是你还是需要明白它具体的细节  \n\n\nSSH是Secure Shell 的缩写，在Linux系统里面最常用的是OpenSSH,幸运的是，只要你不是从逻辑安装linux，否则OpenSSH通常都是预先安装在你的电脑上的，如果没有的话简单的Google一下安装上就可以了。\n\nOpen SSH是个非常好的东西，因为它允许公钥与私钥配对。公、私钥配对可以应用在各种各样的事务上面，通常的例子有：普通加密，服务器认证，已经Git 认证。\n\n公、私钥对从名称来看就知道分公钥和私钥，私钥是不被公开共享的，只有电脑主机拥有。公钥是可以放置在任何一台电脑上，拿来与公钥匹配的。这里有个例子：\n\n\n\n通过查看上面的例子，可以看到你自己的公钥出现在了DigitalOcean，Linode和GitHub上面，这意味着你的笔记本电脑有和这些电脑通讯，它的私钥将要与与之通讯的这些电脑的私钥做匹配验证，只有验证通过后你的笔记本电脑才可以与他们通讯。\n\n这种认证方式只能是但方向的，意味着你的电脑可以访问 Digital Ocean, Linode, 和Github，但是他们却不可以通过匹配公钥访问你的电脑。\n\n最后你应该也看到了Linode和Github也有做公私钥匹配，Linode也可以访问Github。\n\n这是一个简短的介绍，我很建议有兴趣的同学去阅读以下这些比我这个非专业人士解释的更好的资料（PS.原博主比较谦虚和厚道）：\n\n\n  Wikipedia: Public-key cryptography \n  Ubuntu  Docs: Ubuntu  Docs\n\n\n####公钥认证VS普通密码认证\n\n从安全层面来讲，这两个有被激烈讨论过。他们两都是保证数据安全的策略，但是哪个更好常常是争论的焦点，最终答案得看你对用户信任度有多高。\n\n很多人认为，使用密码认证的时候，用户通常记不住或者不能够被信任，他们认为公、私钥认证的方式比密码认证更安全。但是有些系统管理员却希望禁用公、私钥认证，因为如果用户丢失电脑，那么他们就丢掉了所有在其他电脑上的公钥，除非重新设置公钥。(下面原文有一段比喻。太长了做个简短概况：SSH的公钥认证就类似于你自家的门安装的使用钥匙开门的锁，密码认证就相当于安装了密码锁，使用钥匙开门的锁一旦丢掉了钥匙，很有可能门就不安全了，这时候你得换锁，然后从新给你家人新的钥匙。而密码锁你可以定期的重置密码，做这个比喻的人喜欢密码锁)\n\n####创建SSH 公钥、私钥\n\n#####首先检查是否有设置过公、私钥\n\nls -al ~/.ssh\n\n\n如果有看见id_rsa 和 id_rsa.pub，说明你的电脑已经有过公、私钥了，如果没有则执行：\n\nssh-keygen -t rsa -C \"your-email-here\"\n\n\n具体细节见GitHub：https://help.github.com/articles/generating-ssh-keys\n\n生成好公钥私钥后在~/.ssh目录下面就有了id_rsa 和 id_rsa.pub文件，第一个文件就是私钥,\n你永远都没有必要操作它。第二个就是你的公钥了，你可以将它放到其他任何一台电脑上\n\n####确保远程服务器准备好接受公钥\n\n现在我们已经准备好了自己电脑的公钥和私钥，我们需要把公钥复制到远程服务器上用以做匹配，但是首先我们得确保远程服务器上所有东西都准备好了。同样在远程服务器上执行命令：  \n\nls -al ~/.ssh\n\n\n如果远程服务器没有.ssh文件夹，你可以按照上面讲的步骤来创建它。当创建完毕后你需要创建一个authorized_keys 文件。\n\ncd ~/.ssh\ntouch authorized_keys\n\n\n接下来确保文件权限设置正确  \n\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_keys\n\n\nOK。完成之后远程服务器就可以接受你的公钥public key了。在authorized_keys文件中每一行就是一个public key\n\n####复制公钥到远程服务器\n\n通常来说复制公钥到远程服务器并没有看起来那么简单，这里有些例子讲如何操作它：\n\n#####老式的复制方式：\n\n如果你有远程服务器权限，你可以直接打开authorized_keys文件然后粘贴你的公钥进去，或者如果你using iTerm on a Mac，你可以通过VIM，vi或者Nano Cli editors 复制粘贴。\n\n如果你在Mac电脑上你可以使用以下命令来复制你的公钥到剪切板：\n\npbcopy < ~/.ssh/id_rsa.pub\n\n\n#####精妙的命令行操作方式：\n\n如果你想很快的完成这项操作，仅仅使用UNIX的CAT 命令就可以了。在MAC上可以直接操作，但是如果是在window上可以使用这里的方式(又是一篇博文讲如何操作shell 在window上的),只需要更改user@host就可以了：\n\ncat ~/.ssh/id_rsa.pub | ssh user@host 'cat >> .ssh/authorized_keys'\n\n\n你应该会被提示输入访问远程服务器的密码，输入后就完成了，相当简单灵活的方式完成了。现在远程服务器你打开authorized_keys，你会发现你的公钥在这个文件里面了。然后当你通过ssh链接到远程服务器的时候就不需要再输入密码了。你已经成功的设置了SSH公钥认证。\n\n####创建SSH快捷方式\n\n到这里，我们已经对公钥私钥认证有了一个基本的理解，我们通过SSH登录远程电脑不需要密码了，最后一件事件我想分享给你的是如何设置SSH快捷方式\n\n如果你管理着许多在不同服务器上的网站，将会很困难记住所有这些用户名、密码和、IP地址 和主机名。然后呢，这里有种方式可以创建快捷方式对你所有的网站。例如你可以创建一个快捷方式：\n\nssh scotch\n\n\n设置这个是相当简单的，在你本地电脑上创建一个config文件到你的~/.ssh文件夹。然后配置如下config：\n\nHost scotch\n\tHostName scotch.io\n\tUser nick\n\nHost example2\n\tHostName example.com\n\tUser root\n\nHost myclient\n\tHostName 64.233.160.0\n\tUser user2ab1\n\t\n\nHost myotherclient\n\tHostName 64.233.160.0\n\tUser userxyz123\n\tPort 56000\n\nHost amazon\n\tHostName ec2.amazon.com\n\tUser ec2-user123\n\tPort 12345\n\tIdentityFile /path/to/special/privatekey/amazon.pem\n\n\n现在如果我们输入以下这些命令就可以登录到对应的服务器了：\n\nssh scotch\nssh example2\nssh myclient\nssh myotherclient\nssh amazon\n\n\n####总结：\n\n以上就是全部拉！我相信你们很多人已经有过这些经验了。但是如果是第一次做的话上面的内容还是很有用处的。不是所有人都会对服务器有很深的掌握。这篇文章的目的仅仅是带你入门，所有我鼓励你们去学习更多，不要仅仅局限于这篇文章，并且要乐于学习哦！\n\n原文链接：http://scotch.io/tutorials/how-to-setup-ssh-public-key-authentication\n\n"},{"title":"PHP上传shell注入(一)","url":"http://akulubala.github.io//php/2014/04/19/PHP-image-way-web-shell_1.html","date":"2014-04-19 00:00:00 +0800","categories":["php"],"body":"\n  首先准备上传文件phpinfo.php\n\n\n<?php\n    echo phpinfo();\n\n\n  上传文件脚本fileup.php\n\n\n<?php                                                                \n         $valid_types = array('image/jpeg','image/jpg','image/gif','image/png');\n         if(isset($_FILES['filedata']))\n         {\n           if(is_uploaded_file($_FILES['filedata']['tmp_name'])&&in_array($_FILES['filedata']['type'],$valid_types))\n          {\n           $new_filename = \"/var/www/test/f_image_\".$_FILES['filedata']['name'];\n          $uploaded = move_uploaded_file($_FILES['filedata']['tmp_name'],$new_filename);\n          }\n                  if($uploaded)\n                  {\n                          if($image = getimagesize($new_filename))\n                          {\n                                  print_r($image);\n                          }\n                          else\n                          {\n                                  echo \"Bad image resource\";\n                          }\n                 }\n                else\n                {\n                          echo \"not uploaded!\";\n                  }\n         }\n\n\n  CURL命令行上传（方便操作）\n\n\ncurl \\ \n        --form 'any_post_data=value' \\ \n        --form 'filedata=@phpinfo.php;filename=phpinfo.php; type=image/gif' \n        'http://localhost/test/fileup.php'\n\ncurl 模拟一个post请求，具体看man curl\n\n经过上面的准备工作，及第三步请求，我们得到一个反馈：\n\n![enter image description here](http://akulubala.github.io/public/images/2014/web_shell_1.png)\n\n说上传的文件不是image\n\n\n\n接下来关键点来了.\n\n\n\n  \n    修改phpinfo.php 让它变成image\n\n    首先需要一个可以查看2进制(16进制)文件的工具。linux 下面 vim可以直接使用系统的xxd(\n也可以下载hexedit来查看)：  \n\n    首先使用file phpinfo.php  得到结果\n  \n\n\nray@ubuntu:/var/www/test$ file phpinfo.php \n        phpinfo.php: PHP script, ASCII text->这里是命令行结果,太小不截图了\n\n使用vim 查看一个gif文件：\n\n    vim -b filename.gif //-b选项不加查看的时候会自动加上0x0a回城符\n    :%!xxd\n    //查看完了需要使用%！xxd -r 是还原二进制文件到文本模式\n\n执行完上面两步后：\n\n![enter image description here](http://akulubala.github.io/public/images/2014/web_shell_2.png)\n\n看到最后一栏有GIF89a的字样，这个就是gif标识文件格式的地方。  \n打开phpinfo.php\n再第一行加入GIF89a几个字符(也可以编辑头六个字节：47 49 46\n38 39 61，建议使用GHex)，注意这里使用编辑器编辑最好是替换，因为二进制文件排列是紧密的块形式    \n然后再使用file phpinfo.php命令查看得到： \n\n    ray@ubuntu:/var/www/test$ file phpinfo.php \n    phpinfo.php: GIF image data, version 89a, 15370 x 28735\n\n看来文件已经变成了GIF了但是文件大小却不对，从<a href=\"http://en.wikipedia.org/wiki/Graphics_Interchange_Format\">gif wiki</a>\n上看到头六个字节表示GIF89a，第7,8（000006-000007），9,10(000008,000009)个字节表示图片大小\n\n    6:     03 00        3            - logical screen width in pixels\n    8:     05 00        5            - logical screen height in pixels\n\n更改想要的大小如0001,0001，再使用file 查看文件大小就变成了\"1\\*1\"了\n\n更改完成再次进行第三步中的curl操作，可以发现已经可以正常上传这个假的图片文件了。\n\n更改PNG文件类似，但是PNG的头信息和gif不同：  \n\n    文件头：由八个字节组成，0x89504e470d0a1a0a\n    数据块：每个数据块由四部分构成，他们的描述依次如下：\n    Length ：占四字节，表示数据块data域占多少个字节。（注意这里不包括length自身）\n    Type ：占四字节，表示当前块的类型。一般是英文大小写字母的ASCII码（65～9>0或者97～122）\n    Data：数据区。大小可以是0字节\n    CRC：占四个字节，整个chunk的CRC校验码（Length+Type+Data） \n\n![enter image description here](http://akulubala.github.io/public/images/2014/web_shell_3.png)\n\n除去头文件信息是第一行前八个字节外，其他信息依次4个字节表示\n\n\n\n  \n    上传真正的shell脚本\n\n    出名的shell脚本从这里可以找到：  \nhttp://www.r57shell.net/  \n里面有个C999的源码翻译过来的  \nhttp://mikeybeck.com/hacking/viewC999.php\n\n    今天就到这里吧…好困了。。\n  \n\n\n"},{"title":"Laravel 框架开发配置概述","url":"http://akulubala.github.io//php/2014/04/21/Laravel_details.html","date":"2014-04-21 00:00:00 +0800","categories":["php"],"body":"使用框架的好处简直太多了，便于管理，加速开发，使用新理念新技术。Laravel 4基于PHP 5.3以上开始的。\n\n###1.命名空间:namespace\n\n    <?php\n    namespace Stark;\n    class Test{\n    }\n    \n    其他文件（首先需要加载进来）：\n    use Stark\\Test;\n    $eddard = new Test();\n    \n    或者不引入直接(全局引用方式):\n    $eddard = new Stark\\Test();\n\n\n文件目录结构，如：library/Stark\n一般都会有自动加载将library下面的所有文件加载  \n\n###2.Closures\n    $x = “a”;\n\n$y = \"b\";\n\n$z = \"c\";\n\n $greet = function($params) use($x,$y,$z)\n {\n     echo  $params;\n     return $x.$y.$z;\n     \n };\n \n$greet(\"abc\");\n\nfunction x($a){\n    var_dump($a);\n}\nfunction y($x)\n{\n\t$w = $x(\"xyz\");\n\tvar_dump($w);\n}\nx($greet);\ny($greet);\n\n\n匿名函数第一个括号是调用时传的参，第二个是创建是传的参，运行上面的小例子，结果：\n\nabc\n\nobject(Closure)[1]\n\nxyz\n\nstring 'abc' (length=3)\n\n\n###3.composer 使用\n\n安装过程就不说了，直接看官方文档.https://getcomposer.org/book.pdf\n composer配置文件是基于json的，例如我要安装一个monolog(手册上例子)：\n 在根目录monolog-demo下面建立一个composer.josn文件，内容：\n\n {\n\t\"require\" : {\n\t\t\"monolog/monolog\": \"1.2.*\"\n\t}\n}\n然后使用命令：composer install，就可以完成下载及安装了\n\n\n下载完成后会多了一个vendor目录，里面有个monolog 目录了。\n composer的配置项有很多，但最重要的就是 这个require和autoload配置了。\n composer的自动加载机制基于 PSR-0/4 也就是说在\n\n\"autoload\": {\n\t\"classmap\": [\n\t],\n    \"psr-4\": {\n            \"\": [\"app/module/\",\"app/library\"]\n     },\n    \"psr-0\": {\n    },\n    \"psr-1\":{\n    },\n    \"psr-2\":{\n    },\n    \"psr-3\":{\n    }\n}\n\n\n关于psr具体介绍看这里：http://www.php-fig.org/faq/\n 注：我自己添加了psr-4将app/module/ 和app/library加入了自动加载中。psr-0的namespace和目录是对应的,psr-4不需要对应namaspace\n 例如：\n\n    \" Monolog \\\\\": \"src /\",//psr-0对应的目录是src/Monolog,psr-4对应src\n    \" Vendor \\\\ Namespace \\\\\": \"src /\",//psr-0对应的目录是src/Vendor/namespace,psr-4对应src\n    \" Vendor_Namespace_ \": \"src /\"//psr-0对应的目录是src/Vendor_Namespace_,psr-4对应src   classmap是机制会自动搜索.inc和.php文件或者搜索特定文件：\n  \n      \" classmap \": [\" src /\", \"lib /\", \" Something .php \"]\n\n\n###4.安装Laravel（其实现在大多数框架的安装方式都是类似的）\n\n    composer create-project laravel/laravel laravel-demo-name//这一步仅仅是下载了laravel应用程序包\n    composer install//这一步是根据composer 下载依赖包\n\n\n上面两部完成之后就有了个vendor目录这个就是composer 包管理的所有文件。还有两个命令\n\ncomposer self-update //更新依赖包\ncomposer dump-autoload //更改过composer.json 配置文件后需要执行这个,重新生成autolod文件\n\n\n接下来配置 rewrite（下面是个标准的nginx配置，框架自带的有apache配置）：\n\nserver {\n\n# Port that the web server will listen on.\nlisten 80\n\n# Host that will serve this project.\nserver_name app.dev\n\n# Useful logs for debug.\naccess_log /path/to/access.log;\nerror_log /path/to/error.log;\nrewrite_log on;\n\n# The location of our projects public directory.\nroot /path/to/our/public;\n\n# Point index to the Laravel front controller.\nindex index.php;\n\nlocation / {\n# URLs to attempt, including pretty ones.\n#按顺序检查文件是否存在，返回第一个找到的文件\n#结尾的斜线表示为文件夹-$uri/。如果所有的文件都找不到，会进行一个内部重定向到最后一个参数\n\n#例如try_files /app/cache/ $uri @fallback;\n\n#它将检测$document_root/app/cache/index.php,$document_root/app/cache/index.html\n#和$document_root$uri是否存在，如果不存在着内部重定向到 @fallback\n        \n    try_files $uri $uri/ /index.php?$query_string;\n\n}\n\n# Remove trailing slash to please routing system.\nif (!-d $request_filename) {\n rewrite ^/(.+)/$ /$1 permanent;\n}\n\n# PHP FPM configuration.\nlocation ~* \\.php$ {\nfastcgi_pass unix:/var/run/php5-fpm.sock;\nfastcgi_index index.php;\nfastcgi_split_path_info ^(.+\\.php)(.*)$;\ninclude /etc/nginx/fastcgi_params;Getting Started 46\nfastcgi_param SCRIPT_FILENAME $document_root$\\\nfastcgi_script_name;\n}\n\n# We don't need .ht files with nginx.\nlocation ~ /\\.ht {\ndeny all;\n}\n\n}\n\n\n###5.框架分析与配置\n\n框架结构目录：\n\n    • app/-->所有代码自己的代码都是在这里面的\n        • commands/-->自己创建Artisan 命令文件目录\n        • config/-->以数组形式存放的一系列配置信息，包括db，router等等\n        • controllers/-->controller文件夹\n        • database/-->如果使用命令行操作方式，关于数据库建库过程，表关系 等等文件，以备将来使用或者迁库\n        • lang/-->国际化配置文件夹，翻译用的\n        • models/-->数据模型\n        • start/-->应用程序启动配置，区别于bootstap\n        • storage/-->本地化存储，包括sesion，view,cache等等\n        • tests/-->所有写的基于phpunit的测试文件\n        • views/-->模板目录\n        • filters.php-->路由过滤控制方法\n        • routes.php-->非常重要的,所有框架路由都在这一个文件中\n    • bootstrap/-->框架启动的配置都在这个目录里面\n    • vendor/-->框架的依赖包以及第三方包\n    • public/-->静态文件目录\n    • artisan-->可执行的文件，包括一些列laravel框架快捷操作方式\n    • composer.json-->composer 配置文件\n    • composer.lock\n    • phpunit.xml-->phpunit test 的配置文件\n    • server.php-->开发中的未来需要的\n\n\n框架启动，路由(写在routes.php)里,我这里写过几个，过多的还是 去看手册：\n\nRoute::get('/games/csol', 'Csol\\Fight\\Controller\\IndexController@showWelcome');\nRoute::get('/cp', 'Cp\\CallBack\\Controller\\IndexController@showWelcome');\n\nRoute::Group(array(\"namespace\"=>\"Test\\Eloquent\\Controller\",'prefix' => 'test'),function(){\n    Route::resource('curd', \"IndexController\");\n});\nRoute::Group(array(\"namespace\"=>\"Test\\Wechart\\Controller\",\"prefix\"=>\"wechart\"),function(){\n    Route::get('/curl',function(){\n        $ch = curl_init();\n\n        // 设置URL和相应的选项\n        curl_setopt($ch, CURLOPT_URL, \"http://laravel/wechart/recieve?ss=fdsdf\");\n        curl_setopt($ch, CURLOPT_HEADER, 0);\n        // 抓取URL并把它传递给浏览器\n        curl_exec($ch);\n\n        // 关闭cURL资源，并且释放系统资源\n        curl_close($ch);\n    });\n    Route::get(\"/recieve\",function(){\n        $response = Response::make();\n        $response->setContent(\"<html><body><h1>Hello world a!</h1></body></html>\");\n        $response->setStatusCode($response::HTTP_OK);\n        $response->headers->set('Content-Type', 'text/html');\n        return $response;\n    });\n});\n-->上面是个例子，curl 会请求recieve route,recieve 返回一个自定义相应\nRoute::Group(array(\"prefix\"=>\"games/portal\"),function(){\n    Route::Group(array(\"namespace\"=>\"Portal\\StewardPoint\\Controller\"),function(){\n        Route::get(\"/steward_point\",\"IndexController@index\");\n        Route::get(\"/steward_point_get\",\"IndexController@getPoint\");\n    });\n});\n\n\n目前我的项目路径，分层分结构如下：  \n\n\n\n结构比较清晰，代码部分一般都在module和library Tiancity下面。  \nLibrary下面有个CustomFacade ，说到这个就引出一个Laravel非常重要的东东了。Facade..\n\n###6.核心理念Facade和IOC\n\nLaravel 里面许多东西都是以Facede形式存在的(外观模式),从Routers.php文件看到rouget::method方式调用方法，如果深入去找这个方法，是找不到具体方法的，最终会找到这个目录：vendor/laravel/framework/src/Illuminate/support/facades/ \n\n在这个文件夹下所有的文件都是一个假的类用来做外观的。这也是laravel的 所有可以使用facade的类。\n\n知道了Facade这个东西，现在来说说如何使用Facade。\n\n首先需要另一个概念：IOC容器，直接把它理解为一个管理类的容器就可以了，现在一个比较好的设计是依赖注入，使用个例子来说明IOC：\n\nclass Foo{\n    private $string = \"i'm foo\";\n    protected $bar;\n\n    public function __construct(Bar $bar) {\n        $this->bar = $bar;\n    }\n}  \n\nclass Bar{\n    private $porperty = \"i'm bar'\";\n\n}\n\nclass Ioc{\n    \n    private static $register = array();\n    \n    public static function bind($name,  callable $resover)\n    {\n        static::$register[$name] = $resover;\n    }\n    \n    public function make($name)\n    {\n        if(isset(static::$register[$name]))\n        {\n            $resolver = static::$register[$name];\n            return $resolver();\n        }\n        throw new Exception(\"No class found!\");\n    }\n}\n\nIoc::bind(\"foo\", function(){\n    return new Foo(new Bar());    \n});\n\n$foo = Ioc::make(\"foo\");\necho \"<pre>\";\nvar_dump($foo);\necho \"</pre>\";\n\n\n上面这个例子说明了一个基本的IOC绑定及使用原理，Laravel使用比这个复杂多的容器，可以去阅读Illuminate\\Container\\Container类\n\n我们在Laravel里使用的时候首先需要注册服务组件里面\n\nnamespace TianCity\\CustomFacade;\nuse Illuminate\\Support\\ServiceProvider;\nuse TianCity\\Tools;\nuse TianCity\\Common;//注意这里，这个文件就是我们可以任意写方法的类，如Common::test(),就会调用该类的方法\nclass TiancityServiceProvider extends ServiceProvider {\n    //put your code here\n        /**\n     * Register the binding\n     *\n     * @return void\n     */\n    public function register()\n    {\n        $app = $this->app;\n        $app->bind(\"Common\",function(){\n            return new Common();\n        });\n        $app->bind(\"Tools\",function(){\n            return new Tools();\n        });\n    }\n}\n\n\n还需要到config/app.php里面providers数组里面加入：’TianCity\\CustomFacade\\TiancityServiceProvider’    \n服务组件是框架引导的时候自动加入的，也就是说 框架加载的时候会有个bind动作，不然你需要手动bind  \n\n然后像前面提到的Facade一样：\n\nnamespace TianCity\\CustomFacade;\nuse Illuminate\\Support\\Facades\\Facade;\nuse App;\nclass Common extends Facade{\n    //put your code here\n     protected static function getFacadeAccessor() { \n            return App::make('Common'); \n    }\n}\nOK...Facade 搞定\n\n\n###7.Filter\n\n加一个Controller 里使用Filter检查是否开放外服 IP的方法： \n\n Route::filter(\"open_ip\",function(){\n    $args = func_get_args();\n    $openIP = array_pop($args);    \n    \n    $ip = sprintf(\"%u\", ip2long(htmlspecialchars($_SERVER['REMOTE_ADDR'])));\n    $net_c = sprintf(\"%u\", ip2long(\"192.168.255.255\")) >> 16;\n    $local = sprintf(\"%u\", ip2long(\"127.0.0.1\")) >> 16;\n    $intern = false;\n    if(($ip >> 16 === $net_c) || ($ip >> 16 === $local))\n    {\n        $intern = true;\n    }\n    if(intval($openIP) === 0 && !$intern)\n    {\n        $response = Response::make();\n        $response->setContent(\"<html><body><h1>对外IP尚未开放！</h1></body></html>\");\n        $response->setStatusCode($response::HTTP_OK);\n        $response->headers->set('Content-Type', 'text/html');\n        return $response;\n    }\n});\n\n    调用方式：\n    //根据传入的$open_ip来决定是否对外开放\n    \n    $this->beforeFilter(\"open_ip:$open_ip\");\n\n\n就先这些吧…后面空了 再写Model和View..Eloquent active Record 好东东啊…\n\n"},{"title":"Mongodb 安装过程","url":"http://akulubala.github.io//mongodb/2014/04/22/Mongodb_Install.html","date":"2014-04-22 00:00:00 +0800","categories":["mongodb"],"body":"官方文档在这里：http://docs.mongodb.org/manual/tutorial/install-mongodb-on-linux/\n\n首先需要知道,mongod是服务进程,mongo是客户端进程\n\n1.下载解压（可以自由发挥）\n\ncurl -O http://downloads.mongodb.org/linux/mongodb-linux-x86_64-2.6.0.tgz\ntar -zxvf mongodb-linux-x86_64-2.6.0.tgz -C /usr/local/\nmv mongodb-linux-x86_64-2.6.0.tgz mongodb\n\n\n2.建立配置文件及数据存放目录：\n\n/usr/local/mongodb/bin/mongodb.conf->配置文件\n/usr/local/mongodb/db->数据存放目录\n/usr/local/mongodb/log/mongodb.log->log 文件\n\n\n3.配置文件内容：\n\ndbpath=/usr/local/mongodb/db\nlogpath=/usr/local/mongodb/log/mongodb.log\nlogappend=true\nfork=true->后台demon运行\n\n\n4.启动..\n\n需要配置环境变量\n以何种身份运行mongod，root的话切换到root 编辑~/.bashrc\nexport PATH=$PATH:/usr/local/mongod/bin\n\nmongod->启动命令\n\n\n5.测试安装状况:\n\nmongo\ndb.version();\n\n\n"},{"title":"php 添加mogodb扩展+PHP点击图片上传并实现预览效果","url":"http://akulubala.github.io//php/2014/05/06/click_image_upload_&_php_mongodb_extension.html","date":"2014-05-06 00:00:00 +0800","categories":["php"],"body":"####PHP添加扩展MongoDB\nPHP添加扩展的方式大致都是一致的，这里记录下今天安的这个，免得改天又忘了。\n\n\ttar zxvf mongo-1.5.1.tgz -C ../\n\tcd mongo-1.5.1/\n\tphpize\n\t./configure --with-php-config=/usr/local/php/bin/php-config\n\tmake clean->这里有时候会报错所以需要这步，看情况来吧\n\tmake\n\tmake install\n\textension=mongo.so\n\n\n####PHP点击图片上传并实现预览效果（主要记录这个）\n\n客户端代码：\n\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\">\n      <title>click image upload</title>  \n      <script type='text/javascript' src='http://code.jquery.com/jquery-1.6.3.js'></script>  \n      <style type='text/css'>\n        #picture {\n            opacity: 0;\n            filter: alpha(opacity=0);\n            position: absolute;\n            height: 220px;\n            width: 220px;\n        }\n        /**\n        上面这段CSS的目的是将file input 按钮覆盖在图片上面以便让人觉的点击的是图片，其实关键也就是这里\n        **/\n      </style>\n    </head>\n    <body>\n        <form id=\"fileform\" action=\"./progress.php\" method=\"POST\" enctype=\"multipart/form-data\" target=\"xxx\">\n            <input type=\"file\" name=\"file\" onchange=\"upload();\" id=\"picture\">\n            <span id=\"filename\"></span>\n        </form>  \n      <img id=\"images\" src=\"./test.jpg\" alt=\"img\">\n      <iframe id=\"xxx\" name=\"xxx\"></iframe>\n      -->如果想要实现无刷新上传，直接写Iframe IE下会报错，所以还是建议用jquery插件来实现\n      <script type=\"text/javascript\">\n        function upload(){\n          $(\"#fileform\").submit();\n        }\n      </script>\n    </body> \n    </html>\n\n\n服务端代码：\n\n    <?php\n    $fp = fopen($_FILES['file']['tmp_name'], 'rb', 0);\n    $image = base64_encode(fread($fp,filesize($_FILES['file']['tmp_name'])));\n    fclose($fp);\n    $src = \"data:image/png;base64,\".$image;\n    -->注意ie8以下不支持data:image/png;base64这样的数据，所以如果需要IE8以下浏览器，请直接使用图片地址\n    echo '<script>window.top.document.getElementById(\"images\").src=\"'.$src.'\";</script>';\n\n"},{"title":"Mysql 存储过程举例","url":"http://akulubala.github.io//mysql/2014/05/12/MYsql_procedure.html","date":"2014-05-12 00:00:00 +0800","categories":["mysql"],"body":"\n  \n    创建过程：\n\n    必须具有CREATE ROUTINE权限，并且ALTER ROUTINE和EXECUTE权限被自动授予它的创建者。\n两种方式，及参数语法说明：\n\n     CREATE PROCEDURE sp_name ([proc_parameter[,...]])\n     [characteristic ...] routine_body\n     \n CREATE FUNCTION sp_name ([func_parameter[,...]])\n     RETURNS type\n     [characteristic ...] routine_body\n        \n     proc_parameter:\n     [ IN | OUT | INOUT ] param_name type->IN 传入参数，OUT 传出参数,INOUT 即可传入又可传出\n        \n     func_parameter:\n     param_name type\n     \n type:\n     Any valid MySQL data type\n     \n characteristic:\n     LANGUAGE SQL\n   | [NOT] DETERMINISTIC\n   | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }\n   | SQL SECURITY { DEFINER | INVOKER }\n   | COMMENT 'string'\n     \n routine_body:\n     Valid SQL procedure statement or statements\n    \n  \n  \n    查看及删除\n\n     查看：\n SHOW CREATE PROCEDURE `procedure name`\n SHOW CREATE FUNCTION  `function name`\n 删除：\n DROP PROCEDURE/FUNCTION [if exists]  procedure/function_name   \n    \n  \n  \n    变量\n\n     1) 用户变量：\n    \n set @var 若没有指定GLOBAL 或SESSION ，那么默认将会定义用户变量，\n 如 set @a =3,@a:=5；set @f := select f from table \n 用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效\n    \n 2) 全局变量：\n    \n 定义时，以如下两种形式出现，set GLOBAL 变量名  或者  set @@global.变量名 \n 对所有客户端生效。只有具有super权限才可以设置全局变量\n    \n 3) 局部变量：作用范围在begin到end语句块之间。在该语句块里设置的变量\n    \n declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量\n    \n 4) 会话变量：\n\n 只对连接的客户端有效。set session varname = value; shwo session variable 来查看\n    \n  \n  \n    例一：\n\n     DELIMITER $$ #定义结束标志\n DROP PROCEDURE IF EXISTS `pr_add`;$$\n #创建存储过程\n CREATE PROCEDURE `pr_add`()\n      BEGIN\n               \n           declare n int default 0;   \n              declare bb int;\n           DECLARE cur_1 CURSOR FOR SELECT action_id FROM useraction where uid=xxx;//取得游标，相当于数字的key\n           DECLARE CONTINUE HANDLER FOR NOT FOUND SET n = 1;//如果记录取完，游标设置为1；\n     \n           OPEN cur_1;\n           FETCH cur_1 INTO bb;\n           while n<>1 do           \n                   replace into useraction set action_id=bb,uid=xxx;\n                   FETCH cur_1 INTO bb; /*取下一条记录，游标每取一次会自动向后进一*/\n               end while;\n               close cur_1;\n      END$$\n DELIMITER ;\n #调用存储过程\n CALL pr_add();\n    \n  \n  \n    例二\n\n     DELIMITER $$ #定义结束标志\n    \n DROP PROCEDURE IF EXISTS `curdemo`;$$\n    \n #创建存储过程\n CREATE PROCEDURE curdemo()\n BEGIN\n   DECLARE done INT DEFAULT 0;-->declare这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个DEFAULT子句\n   DECLARE a CHAR(16);\n   DECLARE b,c INT;\n   DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;-->申明光标cur1\n   DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;\n   DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;\n     \n   OPEN cur1;\n   OPEN cur2;\n   REPEAT-->REPEAT语句内的语句或语句群被重复，直至search_condition 为真\n     FETCH cur1 INTO a, b;-->这个语句用指定的打开光标读取下一行（如果有下一行的话），并且前进光标指针。\n     FETCH cur2 INTO c;\n     IF NOT done THEN\n        IF b < c THEN\n           INSERT INTO test.t3 VALUES (a,b);\n        ELSE\n           INSERT INTO test.t3 VALUES (a,c);\n        END IF;\n     END IF;\n   UNTIL done END REPEAT;\n   CLOSE cur1;\n   CLOSE cur2;\n END\n    \n  \n  \n    例三\n\n     delimiter $$\n    \n DROP PROCEDURE IF EXISTS `fs2_first_active_lottery`;$$\n    \n CREATE PROCEDURE fs2_first_active_lottery (IN curr_l_time datetime,IN u_id varchar(45),OUT a_type tinyint(3) unsigned,OUT out_time datetime)\n    \n BEGIN\n DECLARE curr_id INT;\n    \n DECLARE counts_awards tinyint(3) unsigned  default 0;\n    \n select sum(award_type) into counts_awards from fs2_first_active_lottery_records where user_id=u_id and award_type!=0 group by user_id for update;\n    \n if counts_awards =0 then //还没有中过奖\n    \n SELECT id,date_distribute,awards_type into curr_id,out_time,a_type FROM db_freestyle_event.fs2_first_active_awards_infos\n where date_distribute<curr_l_time and status='Y'  limit 1 for update;\n elseif counts_awards=1 then\n set a_type =2;\n    \n SELECT id,date_distribute,awards_type into curr_id,out_time,a_type FROM db_freestyle_event.fs2_first_active_awards_infos         where date_distribute<curr_l_time and status='Y' and awards_type=a_type  limit 1 for update;\n elseif counts_awards=2 then\n set a_type =2;\n    \n SELECT id,date_distribute,awards_type into curr_id,out_time,a_type FROM db_freestyle_event.fs2_first_active_awards_infos         where date_distribute<curr_l_time and status='Y' and awards_type=a_type  limit 1 for update;\n end if;\n    \n update db_freestyle_event.fs2_first_active_awards_infos set status='N' where id=curr_id;\n END$$\n    \n $call_procedure = sprintf(\"call fs2_first_active_lottery('%s','%s',@m1,@m2);\",  $currDate,$this->uid);\n    \n  $sql = sprintf(\"select @m1 as award_type,@m2 as distribute_date\");\n    \n  \n\n\n官方文档：http://dev.mysql.com/doc/refman/5.1/zh/stored-procedures.html\n\n"},{"title":"Ubunto Deploy Jekyll","url":"http://akulubala.github.io//linux/2014/06/27/Ubunto_Deploy_Jekyll.html","date":"2014-06-27 00:00:00 +0800","categories":["linux"],"body":"\n  \n    Download and install ruby\n\n    sudo mkdir Downloads\ncurl -O http://cache.ruby-lang.org/pub/ruby/2.1/ruby-2.1.2.tar.gz \ntar -zxvf ruby-2.1.2.tar.gz -C ../\ncd ..\nsudo chown -R ray ruby-2.1.2\nsudo chgrp -R ray ruby-2.1.2\ncd ruby-2.1.2\n\n./configure  ---->error no gcc installed\n    \n\n    Install gcc\n\n    sudo apt-get install gcc\ngcc -v ---->gcc version 4.8.2\nsudo apt-get install build-essential -->this is needed for gcc to find software infomation \n    \n./configure\nsudo make&make install\n    \n\n    Install rubygem\n\n    culr -O http://production.cf.rubygems.org/rubygems/rubygems-2.3.0.tgz\ntar -zxvf rubygems-2.3.0.tgz -C ../\nsudo chown -R ray rubygems-2.3.0\nsudo chgrp -R ray rubygems-2.3.0\n    \n  \n  \n    Install jekyll\n\n    OK…stupid things came out:\n\n    first error said i need zlib..\n\n    then install zlib\n\n    sudo apt-get install zlib1g-dev\n    \n\n    and rebuild ruby ,rubygems\n\n    Second error said i need openssl\n because i do not have openssl installed..\n\n    sudo apt-get install libssl0.9.8\nsudo apt-get install libssl-dev\n    \n\n    then rebuild ruby,ruby gems..\n\n    Third error said need javascript runtime..\nhere have some illustration https://github.com/jekyll/jekyll/issues/2327\nbut i think it’s jekyll problem ,it’s ask us use coffescript\n\n    gem install execjs\nsudo apt-get install nodejs\n    \n\n    Finally,finished..\n\n    jekyll -v --->ok\n    \n  \n  \n    Deploy my blog\n\n    sudo apt-get install git\ngit clone git@github.com:akulubala/akulubala.github.io.git\n    \n\n    some error because i don’t have some plug-in defined in my Gemfile\n\n    just gem install xx\nthen ./deploy\n    \n\n    see my blog ok…\n  \n  \n    SSH and Sftp\n\n    sudo apt-get install openssh-server\ncd /etc/ssh/\nsudo cp sshd_config sshd_config.defaults_bak--->backup file\nsudo vim sshd_config\nunmake PasswordAuthentication \nsudo restart ssh\n    \n\n    then open terminal :\nlogin system or filezila login\n\n  \n\n"},{"title":"十位用户唯一ID生成策略","url":"http://akulubala.github.io//php/2014/07/07/decade-user_id-strategy.html","date":"2014-07-07 00:00:00 +0800","categories":["php"],"body":"新浪微博和twitter 等系统都有一窜数字ID来标示一个唯一的用户,这篇文章就是记录如何实现这种唯一数字ID\n\n原理：使用MYSQL 自增ID 拼接任意字符..然后使用进制转换打乱规则\n\n一般来说实现唯一性可以使用uniqid 或者time之类的方式生成，但是考虑到多台系统，也就是分布式系统。这种方式就不准确了。\n\n\n实现：\n\n新建一个数据库：\n\nCREATE TABLE `user_number_id` (\n  `id` bigint(20) unsigned NOT NULL auto_increment,\n  `stub` char(1) NOT NULL default '',\n  PRIMARY KEY  (`id`),\n  UNIQUE KEY `stub` (`stub`)\n) ENGINE=MyISAM\n\n\n使用replace into 来取得生成的ID\n\nREPLACE INTO Tickets64 (stub) VALUES ('a');\nSELECT LAST_INSERT_ID() as number_id;\n\n\n取得number_id后生成十位数字ID\n\nfunction auID($autoID)\n{\n    $autoID = $autoID;\n    $autoCharacter = array(\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\");\n    $len = 7-((int)log10($autoID) + 1);\n    $i=1;\n    $numberID = mt_rand(1, 2).mt_rand(1, 4);\n    for($i;$i<=$len-1;$i++)\n    {\n        $numberID .= $autoCharacter[mt_rand(1, 13)];\n    }\n\n    return base_convert($numberID.\"E\".$autoID, 16, 10);--->这里因为autoid永远不可能为E所以使用E来分割保证不会重复\n}\n\n\nbase_convert 转换16进制到10进制，只要16进制不同那么10进制就一定不同，因为10位十进制最大可取范围：9999999999转换成16进制是2540BE3FF所以前两位可取值是固定的mt_rand(1, 2).mt_rand(1, 4)\n\n以下是测试用例表明没有重复(内存问题只测到55万)：\n\n    static $array=array();\n    for($j=1;$j<=550000;$j++)\n    {\n        $array[] = auID($j);\n    }\n    \n    \n    print_r(count(array_unique($array)));\n    \n    function array_repeat($arr) \n    { \n       if(!is_array($arr)) return $arr; \n          \n       $arr1 = array_unique($arr); \n          \n       $arr3 = array_diff_key($arr,$arr1);  \n       \n       return array_unique($arr3); \n    }\n    \n    print_r(array_repeat($array));\n\n\n考虑到可能会有主从需求,id生成应该去取同一个数据表的数据，或者设置好自增id，如主服务器1357，从服务器2468\n\n参考：http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/\n\n"},{"title":"redis数据库设计","url":"http://akulubala.github.io//redis/2014/11/14/redis_design_database.html","date":"2014-11-14 00:00:00 +0800","categories":["redis"],"body":"公司要用redis 做数据存储，主要业务是做图片处理，有这么几个成员：\n>reference\n»这张表记录产品(image)\t\n\n\n  steps\t\n>step记录图片和reference处理到哪一步\n\n\n\n  history\n>history记录step变化详细\n\n\n\n  company\n>company记录reference属于那个company\n\n\n\n  member\n>member是公司员工\n\n\n\n  group\n>员工所属的组\n\n\n\n  work_limit\n>员工可以进行的工作\n\n\n\n\n\n  \n    首先设计reference表 \n\n    reference 有detail,及多个image，存储reference以reference_id来唯一区别，detail有多个属性及值所以需要hash类型存储:\t\n\n     hset pp_reference:example_reference_id_1:detail saas_reference_code code_example_1 \treference_source source1 dist dist1 curr_step step1\n    \n\n    对于搜索的时候需要按时间排序，另外也有可能需要做分页搜索，时间搜索，因此我需要一个zset（可以做range操作）的集合来存储reference的插入时间，并且时间为score，且int型的timestemp，value为reference_id      \n     zadd pp_reference:created_at 12354678(timestemp_example) example_reference_id\n\n    对于reference对应的图片，因为是一对多的关系而且图片也有图片细节，所以每一个reference都将有一个set集合来存储图片的ID（图片详情也存hash并且先于reference存储）：\n\n     sadd pp_reference:example_reference_id:image_id 1 2 12 3\n    \n\n    与reference的history也是一对多的关系，因此也需要存一个像上面图片一样的集合，集合里面存reference_history_id\n\n     sadd pp_reference:example_reference_id:reference_history_id 1 2 12 3\n    \n\n    reference在查询的时候，不会按照id去查询所以需要有一个reference_code与ID的对应(另外因为本身我这里的reference_id是从mysql取得的自增id所以这里不需要设置自增id)\n\n     set pp_reference:reference_code_example_abc 123\n    \n\n    reference 的结构基本就以以上这么一个方式存储\n\n    \n      -与reference相关的子集表:pp_images  \n    \n\n     `hmset pp_image:image_id_1:detail name abc.jpg size 1024k curr_step step2`\t\n    \n\n    \n      由于image需要一个自增id所以还需要：\t\n    \n\n     `setnx pp_image:image_auto_id 0`\t\n `INCR pp_image:image_auto_id`\t\n    \n\n    \n      这样每次存储前先执行这么一个语句取得该ID作为自增ID\n-与reference相关子集表:pp_histtory\t\n    \n\n     `hmset pp_history:pp_history_id_1:detail step_from step_1 step_to step_2  time 2014-06-06 10:10:10`\t\n    \n\n    \n      同样的也需要一个自增id\t\n    \n\n     `setnx pp_history:history_auto_id 0`\n `INCR pp_history:history_auto_id`\t\n    \n\n    \n      查询日志set建立\t\n    \n\n     `zadd pp_history:created_at 12354678(timestemp_example)  example_history_id\t`\t\n    \n\n    \n      使用redis desk manager结构图：\n     \n    \n  \n  \n    steps表\t\n\n    和reference一样存储多种数据，需要hash类型\t\n\n     hmset pp_step:step_1:step_detail name setp_1 isactive 1 description\t\t xxxxxx\n setnx pp_step:step_id 0\n    \n\n    \n      step 是单纯记录各个step意义，实际存放reference 所在step应该有以下设计\t\n    \n\n    sadd step_1:image image_id_1 image_id_2\n sadd step_1:reference reference_1 reference_2\t\n\n    \n      这样当image或者reference的step变化的时候就直接从一个集合拿id到另一个集合，或者说删除一个/添加一个\n>结构图\n    \n  \n\n\n通过上面两个表的建立基本了解了如果建立redis数据库，其主要是需要了解redis各个数据结构的原理及使用范围。通过对应关系可以找出相关的数据这样就可以了。\n\n"},{"title":"Python Decorator","url":"http://akulubala.github.io//python/2014/11/24/python_decorator.html","date":"2014-11-24 00:00:00 +0800","categories":["python"],"body":"我测试 部署\n这个python decorator 大概是每个pythoner比看到内容吧.对于我这个从PHP 过来的人第一次看，确实也有那么些新鲜难懂。顾名思义：“装饰器”，绝对是把什么什么东西通过另外的东西修饰了一番。\n\n####先来看下最基本的显而易见的例子吧：\n\ndef log(func):\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        func(*args, **kw)---\n    return wrapper\n\n@log\ndef now():\n    print '2013-12-25'\n\nnow()\n\n\n@log就是所谓的语法糖，从上例最终的表现形式就是：将now()函数传给了方法log..最终调用是 调用了内部函数wrapper..\n\n接下来一步步刨析：  \nlog函数内部有个wrapper函数，这样就形成了一个闭包wrapper,这个函数对于其他部分是一个独立的模块，但其可以使用log的参数也就是传进来的方法func,func在log内部是相当于warpper是全局变量（log 内部的作用域）经过wrapper的处理后,now函数就不再是单单输出“2013-12-25”了。所以也验证了前面所说的经过某某修饰成为了另外的某某某。相当于now = log(now())\n\n如果前面的例子打印now.__name__,结果为：wrapper 而不是now\n\n为了解决这个问题，需要如下操作：\n\nfrom functools import wraps\ndef log(func):\n\t@wraps(func)\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        func(*args, **kw)---\n    return wrapper **如果now 函数需要传参数的话需要反射来处理，具体可看http://coolshell.cn/articles/11265.html**\n\n\n####以上是一个最基本的decorator 应用，接下来说明在使用decorator时传参    \n\nfrom functools import wraps\ndef log(args1,args2):\n    def real_decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kw):\n            print 'call %s():' % func.__name__\n            func(args1, args1,args)\n        return wrapper\n    return real_decorator\n\n@log(\"log pass paramter1 to log\",\"log pass paramter2 to log\")\ndef now(*args):\n    print args\n    print '2013-12-25'\n\nnow(\"now pass parameter to wrapper\")\nprint now.__name__\n\n\nresult :\n>call now():\n>(‘log pass paramter1 to log’, ‘log pass paramter1 to log’, (‘now pass parameter to wrapper’,))  \n>2013-12-25  \n>now\n\n说明对于需要使用语法糖 传参的时候需要返回一个函数real_decorator，再在内部定义具体调用的函数wrapper这里相当于：log(\"log pass paramter1 to log\",\"log pass paramter2 to log\")((now())\n\n####使用多个decorator:  \n\nfrom functools import wraps\ndef log(args1,args2):\n    def real_decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kw):\n            print 'call %s():' % func.__name__\n            func(args1, args1,args)\n        return wrapper\n    return real_decorator\n\ndef another_log(func):\n    def wrapper(pams):\n        print \"another wrapper of %s():\\n\" % func.__name__+pams\n    return wrapper\n\n@another_log\n@log(\"log pass paramter1 to log\",\"log pass paramter2 to log\")\ndef now(*args):\n    print args\n    print '2013-12-25'\n\nnow(\"now pass parameter to wrapper\")\nprint now.__name__\n\n\nresults:  \n>another wrapper of now():  \n>now pass parameter to wrapper  \n>wrapper\n\n说明：结果是 输出了 another_log 的内容，那么它是将log decrator 过后的方法再次 decorator，即如下形式：another_log(log(param1,param2)(now)),也就是两层包装  \n\n####类式的 Decorator\n\nclass TestDecorator(object):\n\n    def __init__(self,func):\n        self.decorator_fn = func\n    def __call__(self):\n        print self.decorator_fn.__name__\n        self.decorator_fn()\n        print \"inside myDecorator.__call__()\"\n@TestDecorator        \ndef now():\n    print \"2014-01-01\"\n\nnow() 基本的实例如上，在这个类中必须要有__call__方法，而所有关于修饰的内容都应当从__call__方法里面去定义  \n\n\n输出：  \n\n\n  now  \n2014-01-01  \ninside class call()  \n\n\n一个好的完整例子：  \n\nclass MyApp():\n    def __init__(self):\n        self.func_map = {}\n\n    def register(self, name):\n        def func_wrapper(func):\n            self.func_map[name] = func\n            return func\n        return func_wrapper\n\n    def call_method(self, name=None):\n        func = self.func_map.get(name, None)\n        if func is None:\n            raise Exception(\"No function registered against - \" + str(name))\n        return func()\n\napp = MyApp()\n\n@app.register('/')\ndef main_page_func():\n    return \"This is the main page.\"\n\n@app.register('/next_page')\ndef next_page_func():\n    return \"This is the next page.\"\n\nprint app.call_method('/')\nprint app.call_method('/next_page')\n\n\n1）上面这个示例中，用类的实例来做decorator。  \n2）decorator类中没有__call__()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。\n\n更多例子：https://wiki.python.org/moin/PythonDecoratorLibrary\n\n"}]}
